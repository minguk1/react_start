# **REACT**
## 기초
1. 실습 환경 및 시작
    리액트 설치
    Node.js 설치
    VS Code 사용

    VS Code 실행 후 npx create-react-app . 명령어 입력
    전체적인 코드 작성후 npm start 명령어 입력

    index.js 파일과 App.js, App.css 파일을 중심으로 작성

2. 기본 개념
    - **컴포넌트**
        사용자 정의 태그 ( 반드시 대문자로 시작해서 만들 것 )
        ```
        function Header() {
            <header>
                <h1><a href="/">WEB</a></h1>
            </header>
        }
        *
        를 정리해주면 App 내에
        <header>
            <h1><a href="/">WEB</a></h1>
        </header>
        코드를
        <Header></Header>
        로 축약이 가능하다.
        ```

    - **props**
        - 기본 변수 넘길 때
            ```
            function Article(props) {
                return (
                    <article>
                        <h2>{props.title}<h2>
                        <h2>{props.body}<h2>
                    </article>
                )
            }

            function App() {
                return (
                    <div>
                        <Article title="welcome" body="hello web">
                    </div>
                )
            }
            ```
            App 안 Article 태그 속 변수를 넣어주면 그 값과 함께 딕셔너리 형태로 넘어간다.
            그리고 그 딕셔너리 이름은 위에 Article을 정의할 때 쓰는 인자 이름이 된다.

        - 객체를 목록 형태로 넘길 때
            기본 변수를 넘길 때처럼 리스트 전체(중괄호)를 넘기고 바로 받는다면 li 태그 하나에 담기기 때문에 목록 형식으로 바꾸지 못한다.
            따라서 리스트를 넘겨받고 반복문을 이용해 li 태그들을 하나씩 만들어 준다.

            ```
            function Nav(props) {
                const lis = []
                for (let i = 0; i<props.topics.length; i++) {
                    let t = props.topics[i]
                    lis.push(<li key={t.id}><a href={'/read/'+t.id}>{t.title}</a></li>)
                }
                return (
                    <nav>
                        <ol>
                            {lis}
                        </ol>
                    </nav>
                )

            }

            function App() {
                const topics = [
                    {id : 1, title:'html', body:'html is'},
                    {id : 2, title:'css', body:'css is'},
                    {id : 3, title:'js', body:'js is'}
                ]
                return (
                    <div>
                        <Nav topics={topics}></Nav>
                    </div>
                )
            }
            ```
            li 반복문 내 key 값을 설정해야 한다.
    - **이벤트**

        ```
            function Nav(props) {
                const lis = []
                for (let i = 0; i<props.topics.length; i++) {
                    let t = props.topics[i]
                    lis.push(<li key={t.id}><a href={'/read/'+t.id} onClick={event=>{
                        event.preventDefault()
                        props.onChangeMode(event.target.id)
                        어떤 상황에 어떤 인자로 함수를 실행시킬지 결정
                    }}>{t.title}</a></li>)
                }
                return (
                    <nav>
                        <ol>
                            {lis}
                        </ol>
                    </nav>
                )

            }

            function App() {
                const topics = [
                    {id : 1, title:'html', body:'html is'},
                    {id : 2, title:'css', body:'css is'},
                    {id : 3, title:'js', body:'js is'}
                ]
                return (
                    <div>
                        <Nav topics={topics} onChangeMode={(id)=>{
                            alert(id)
                        }}></Nav>
                        어떤 함수를 넘길 것인지 정의
                    </div>
                )
            }
        ```
    - **State**  
        prop은 컴포넌트를 사용하는 외부자를 위한 데이터
        state는 컴포넌트를 만드는 내부자를 위한 데이터

        import {useState} from 'react'

        기본 컴포넌트 내 함수에서 변수를 바꿔준다고 했을 때 컴포넌트가 다시 시작되지 않아 리턴값에 변화가 없다. 이러한 문제를 해결하기 위해(변수값이 변화함에 따라 컴포넌트를 다시 실행하여 새로운 리턴값을 나오게 한다.) state를 사용

        ```
        function App() {
            const [mode, setMode] = useState('WELCOME')
            생략
        }
        ```
        에서 mode 라는 변수명에 'WELCOME' 이라는 문자열의 초기값이 들어가고 이후에
        setMode(A)
        코드를 통해 mode의 변수에 A를 할당할 수 있다.  
        (ex) setMode('READ')

3. CRUD  
    - **CREATE**  
        a태그로 create 링크를 따로 만들고 그 태그를 클릭시 새로고침이 되지 않는 event.preventDefault() 설정과 모드를 CREATE로 바뀌어 content가 Create태그가 되도록 한다.

        ```
            App return 안에
            <a href="/create" onClick={(event) => {
                event.preventDefault()
                setMode('CREATE')
            }}>Create</a>

            else if (mode==='CREATE') {
                content = <Create></Create>
            }
        ```

        다음으로 Create 컴포넌트와 그 안 폼을 만들어 주어야 한다.

        ```
            function Create() {
                return <Article>
                <h2>Create</h2>
                <form>
                    <p><input type="next" name="title" placeholder="title" /></p>
                    <p><textarea name="body" placeholder="body"></textarea></p>
                    <p><input type="submit" value="Create"></input></p>
                </form>
                
                
                </Article>
            }
        ```
        이제 submit이 되었을 때 현재 input 칸에 있는 값들을 변수로 빼와야 한다. 따라서 form 태그에 onSubmit 일 때 함수 내용을 설정하여 준다.

        ```
        <form onSubmit={event=>{
        event.preventDefault()
        console.log(event.target)
        const title = event.target.title.value
        const body = event.target.body.value
        props.onCreate(title,body)
        }}>
        ```
        onSubmit 함수 내 event.target은 이벤트가 발생한 태그이므로 form 태그에 해당하고 거기 안에 name이 title과 body인 태그의 value값을 각각 변수로 설정해준다. 그 설정한 변수들을 기존 리스트에 더해주는 onCreate 함수를 또 Create 태그가 호출당하는 부분에 정의해 준다.

        ```
        else if (mode === "CREATE") {
            content = <Create onCreate={(_title, _body) => {
            const newTopic = {id : nextid, title : _title, body : _body}
            const newTopics = [...topics]
            newTopics.push(newTopic)
            setTopics(newTopics)
            setMode("READ")
            setId(nextid)
            setNextId(nextid + 1)
            }}></Create>
        }
        ```

        위 코드에서 주의할 점으로 범 객체를 수정하기 위해서는 새로운 변수명에 복제본을 만들고 그것을 수정하여 저장해야 한다는 것이다. 또한, create가 될 때마다 id 값이 늘어나야 하므로 App 함수 내 새로 state를 만들어 주어야 한다.

        ```
        const [nextid, setNextId] = useState(4)
        ```
        마지막에 다시 모드를 READ로 바꾸고 최근 id 값(방금 만든 게시글)에 해당하는 글이 보이도록 설정한다.

    - **UPDATE**  
        각 게시글마다 update가 가능하게 하기 위해 READ 모드일 때 update 버튼을 만들어 준다. 현재 읽고 있는 게시글의 id 또한 넘겨줘야 하기 때문에 버튼 클릭 시 id가 포함된 url 링크로 가도록 설정한다.
        contextControl이라는 변수에 저장시켜주고 Create 아래 버튼에 나타내어 준다.
        ```
        else if (mode === 'READ') {
        let title, body = null
        for (let i=0; i<topics.length; i++) {
        
        if (topics[i].id === id) {
            title = topics[i].title
            body = topics[i].body

        }
        }
        content = <Article title={title} body={body}></Article>
        contextControl = <li><a href={"/update/"+id} onClick={event=>{
        event.preventDefault()
        setMode('UPDATE')
        }}>Update</a></li>}
        ```

        ```
        <li>
          <a href="/create" onClick={event=> {
            event.preventDefault()
            setMode('CREATE')
            }}>Create</a>
            {contextControl}
        </li>
        ```

        event.preventDefault()를 넣는 이유는 CREATE 때와 똑같고 모드는 따로 UPDATE 모드로 바꿔 줍니다.

        App 컴포넌트 내 mode가 UPDATE 모드일 때 content가 Update 컴포넌트가 되도록 Update 컴포넌트를 만들어 준다.
        Update 컴포넌트는 Create 컴포넌트 때와 같이 폼을 만들어주어야 하지만 그 폼 안에 내용이 현재 저장되어 있는 값이 나오도록 설정해야 한다. 따라서 Update 컴포넌트가 실행될 때 적절한 props값(현재 READ 모드이니 그 때의 title과 body값)도 같이 넘겨줘야 한다.

        ```
        else if (mode === 'UPDATE') {
            let title = body = null;
            for (let i = 0; i < topics.length; i++) {
                if (topics[i].id === id) {
                    title = topics[i].title
                    body = topics[i].body
                }
            }
            content = <Update title={title} body={body} onUpdate={(title, body) => {

            }}></Update>
        }
        ```
        이렇게 잘 update 폼에 기존 값이 잘 나올 수 있겠지만 입력칸에 값을 수정해도 같은 컴포넌트 안이라서 state를 이용하여 값을 바꿔줘야 한다. onChange 를 이용하여 값이 변화함에 따라 실시간으로 바꿔준다.
        또한, submit이 되었을 때 그 시점 title, body 값에 대한 함수를 실행시켜준다.
        ```
        function Update(props) {
        const [title, setTitle] = useState(props.title)
        const [body, setBody] = useState(props.body)
        return (
            <article>
            <h2>Update</h2>
            <form onSubmit={event=>{
                event.preventDefault()
                console.log(event.target)
                const title = event.target.title.value
                const body = event.target.body.value
                props.onUpdate(title,body)
            }}>
                <p>
                <input type="text" name="title" placeholder='title' value={title} onChange={event=>{
                    setTitle(event.target.value)
                }}/>
                </p>
                <p>
                <textarea name="body" placeholder='body' value={body} onChange={event=>{
                    setBody(event.target.value)
                }}></textarea>
                </p>
                <p>
                <input type="submit" value="Update"></input>
                </p>
            </form>


            </article>
        )
        }
        ```
        마지막으로 create 때와 같이 onUpdate 함수를 정의할 때 넘겨 받은 값을 리스트에 추가하도록 해 주고 그 게시글을 자동으로 READ하도록 해준다.

        ```
        content = <Update title={title} body={body} onUpdate={(title,body) => {
        const updatedTopic = {id:id, title:title, body:body}
        const newTopics = [...topics]
        for(let i=0; i<newTopics.length; i++) {
            if (newTopics[i].id === id) {
            newTopics[i] = updatedTopic
            break
            }
        }
        setTopics(newTopics)
        setMode("READ")
        }}></Update>
        ```

    - **DELETE**